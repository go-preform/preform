// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/go-preform/preform/benchmark/ent/predicate"
	"github.com/go-preform/preform/benchmark/ent/testa"
	"github.com/go-preform/preform/benchmark/ent/testb"
	"github.com/go-preform/preform/benchmark/ent/testc"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeTestA = "TestA"
	TypeTestB = "TestB"
	TypeTestC = "TestC"
)

// TestAMutation represents an operation that mutates the TestA nodes in the graph.
type TestAMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	int4           *int32
	addint4        *int32
	int8           *int
	addint8        *int
	float4         *float32
	addfloat4      *float32
	float8         *float64
	addfloat8      *float64
	bool           *bool
	text           *string
	time           *time.Time
	clearedFields  map[string]struct{}
	test_bs        map[int]struct{}
	removedtest_bs map[int]struct{}
	clearedtest_bs bool
	done           bool
	oldValue       func(context.Context) (*TestA, error)
	predicates     []predicate.TestA
}

var _ ent.Mutation = (*TestAMutation)(nil)

// testaOption allows management of the mutation configuration using functional options.
type testaOption func(*TestAMutation)

// newTestAMutation creates new mutation for the TestA entity.
func newTestAMutation(c config, op Op, opts ...testaOption) *TestAMutation {
	m := &TestAMutation{
		config:        c,
		op:            op,
		typ:           TypeTestA,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestAID sets the ID field of the mutation.
func withTestAID(id int) testaOption {
	return func(m *TestAMutation) {
		var (
			err   error
			once  sync.Once
			value *TestA
		)
		m.oldValue = func(ctx context.Context) (*TestA, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestA.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestA sets the old TestA of the mutation.
func withTestA(node *TestA) testaOption {
	return func(m *TestAMutation) {
		m.oldValue = func(context.Context) (*TestA, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestAMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestAMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestA entities.
func (m *TestAMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestAMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestAMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestA.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TestAMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestAMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestA entity.
// If the TestA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestAMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestAMutation) ResetName() {
	m.name = nil
}

// SetInt4 sets the "int4" field.
func (m *TestAMutation) SetInt4(i int32) {
	m.int4 = &i
	m.addint4 = nil
}

// Int4 returns the value of the "int4" field in the mutation.
func (m *TestAMutation) Int4() (r int32, exists bool) {
	v := m.int4
	if v == nil {
		return
	}
	return *v, true
}

// OldInt4 returns the old "int4" field's value of the TestA entity.
// If the TestA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestAMutation) OldInt4(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInt4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInt4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInt4: %w", err)
	}
	return oldValue.Int4, nil
}

// AddInt4 adds i to the "int4" field.
func (m *TestAMutation) AddInt4(i int32) {
	if m.addint4 != nil {
		*m.addint4 += i
	} else {
		m.addint4 = &i
	}
}

// AddedInt4 returns the value that was added to the "int4" field in this mutation.
func (m *TestAMutation) AddedInt4() (r int32, exists bool) {
	v := m.addint4
	if v == nil {
		return
	}
	return *v, true
}

// ResetInt4 resets all changes to the "int4" field.
func (m *TestAMutation) ResetInt4() {
	m.int4 = nil
	m.addint4 = nil
}

// SetInt8 sets the "int8" field.
func (m *TestAMutation) SetInt8(i int) {
	m.int8 = &i
	m.addint8 = nil
}

// Int8 returns the value of the "int8" field in the mutation.
func (m *TestAMutation) Int8() (r int, exists bool) {
	v := m.int8
	if v == nil {
		return
	}
	return *v, true
}

// OldInt8 returns the old "int8" field's value of the TestA entity.
// If the TestA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestAMutation) OldInt8(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInt8 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInt8 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInt8: %w", err)
	}
	return oldValue.Int8, nil
}

// AddInt8 adds i to the "int8" field.
func (m *TestAMutation) AddInt8(i int) {
	if m.addint8 != nil {
		*m.addint8 += i
	} else {
		m.addint8 = &i
	}
}

// AddedInt8 returns the value that was added to the "int8" field in this mutation.
func (m *TestAMutation) AddedInt8() (r int, exists bool) {
	v := m.addint8
	if v == nil {
		return
	}
	return *v, true
}

// ResetInt8 resets all changes to the "int8" field.
func (m *TestAMutation) ResetInt8() {
	m.int8 = nil
	m.addint8 = nil
}

// SetFloat4 sets the "float4" field.
func (m *TestAMutation) SetFloat4(f float32) {
	m.float4 = &f
	m.addfloat4 = nil
}

// Float4 returns the value of the "float4" field in the mutation.
func (m *TestAMutation) Float4() (r float32, exists bool) {
	v := m.float4
	if v == nil {
		return
	}
	return *v, true
}

// OldFloat4 returns the old "float4" field's value of the TestA entity.
// If the TestA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestAMutation) OldFloat4(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloat4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloat4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloat4: %w", err)
	}
	return oldValue.Float4, nil
}

// AddFloat4 adds f to the "float4" field.
func (m *TestAMutation) AddFloat4(f float32) {
	if m.addfloat4 != nil {
		*m.addfloat4 += f
	} else {
		m.addfloat4 = &f
	}
}

// AddedFloat4 returns the value that was added to the "float4" field in this mutation.
func (m *TestAMutation) AddedFloat4() (r float32, exists bool) {
	v := m.addfloat4
	if v == nil {
		return
	}
	return *v, true
}

// ResetFloat4 resets all changes to the "float4" field.
func (m *TestAMutation) ResetFloat4() {
	m.float4 = nil
	m.addfloat4 = nil
}

// SetFloat8 sets the "float8" field.
func (m *TestAMutation) SetFloat8(f float64) {
	m.float8 = &f
	m.addfloat8 = nil
}

// Float8 returns the value of the "float8" field in the mutation.
func (m *TestAMutation) Float8() (r float64, exists bool) {
	v := m.float8
	if v == nil {
		return
	}
	return *v, true
}

// OldFloat8 returns the old "float8" field's value of the TestA entity.
// If the TestA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestAMutation) OldFloat8(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloat8 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloat8 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloat8: %w", err)
	}
	return oldValue.Float8, nil
}

// AddFloat8 adds f to the "float8" field.
func (m *TestAMutation) AddFloat8(f float64) {
	if m.addfloat8 != nil {
		*m.addfloat8 += f
	} else {
		m.addfloat8 = &f
	}
}

// AddedFloat8 returns the value that was added to the "float8" field in this mutation.
func (m *TestAMutation) AddedFloat8() (r float64, exists bool) {
	v := m.addfloat8
	if v == nil {
		return
	}
	return *v, true
}

// ResetFloat8 resets all changes to the "float8" field.
func (m *TestAMutation) ResetFloat8() {
	m.float8 = nil
	m.addfloat8 = nil
}

// SetBool sets the "bool" field.
func (m *TestAMutation) SetBool(b bool) {
	m.bool = &b
}

// Bool returns the value of the "bool" field in the mutation.
func (m *TestAMutation) Bool() (r bool, exists bool) {
	v := m.bool
	if v == nil {
		return
	}
	return *v, true
}

// OldBool returns the old "bool" field's value of the TestA entity.
// If the TestA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestAMutation) OldBool(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBool: %w", err)
	}
	return oldValue.Bool, nil
}

// ResetBool resets all changes to the "bool" field.
func (m *TestAMutation) ResetBool() {
	m.bool = nil
}

// SetText sets the "text" field.
func (m *TestAMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *TestAMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the TestA entity.
// If the TestA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestAMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *TestAMutation) ResetText() {
	m.text = nil
}

// SetTime sets the "time" field.
func (m *TestAMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *TestAMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the TestA entity.
// If the TestA object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestAMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *TestAMutation) ResetTime() {
	m.time = nil
}

// AddTestBIDs adds the "test_bs" edge to the TestB entity by ids.
func (m *TestAMutation) AddTestBIDs(ids ...int) {
	if m.test_bs == nil {
		m.test_bs = make(map[int]struct{})
	}
	for i := range ids {
		m.test_bs[ids[i]] = struct{}{}
	}
}

// ClearTestBs clears the "test_bs" edge to the TestB entity.
func (m *TestAMutation) ClearTestBs() {
	m.clearedtest_bs = true
}

// TestBsCleared reports if the "test_bs" edge to the TestB entity was cleared.
func (m *TestAMutation) TestBsCleared() bool {
	return m.clearedtest_bs
}

// RemoveTestBIDs removes the "test_bs" edge to the TestB entity by IDs.
func (m *TestAMutation) RemoveTestBIDs(ids ...int) {
	if m.removedtest_bs == nil {
		m.removedtest_bs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.test_bs, ids[i])
		m.removedtest_bs[ids[i]] = struct{}{}
	}
}

// RemovedTestBs returns the removed IDs of the "test_bs" edge to the TestB entity.
func (m *TestAMutation) RemovedTestBsIDs() (ids []int) {
	for id := range m.removedtest_bs {
		ids = append(ids, id)
	}
	return
}

// TestBsIDs returns the "test_bs" edge IDs in the mutation.
func (m *TestAMutation) TestBsIDs() (ids []int) {
	for id := range m.test_bs {
		ids = append(ids, id)
	}
	return
}

// ResetTestBs resets all changes to the "test_bs" edge.
func (m *TestAMutation) ResetTestBs() {
	m.test_bs = nil
	m.clearedtest_bs = false
	m.removedtest_bs = nil
}

// Where appends a list predicates to the TestAMutation builder.
func (m *TestAMutation) Where(ps ...predicate.TestA) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestAMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestAMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestA, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestAMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestAMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestA).
func (m *TestAMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestAMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, testa.FieldName)
	}
	if m.int4 != nil {
		fields = append(fields, testa.FieldInt4)
	}
	if m.int8 != nil {
		fields = append(fields, testa.FieldInt8)
	}
	if m.float4 != nil {
		fields = append(fields, testa.FieldFloat4)
	}
	if m.float8 != nil {
		fields = append(fields, testa.FieldFloat8)
	}
	if m.bool != nil {
		fields = append(fields, testa.FieldBool)
	}
	if m.text != nil {
		fields = append(fields, testa.FieldText)
	}
	if m.time != nil {
		fields = append(fields, testa.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestAMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testa.FieldName:
		return m.Name()
	case testa.FieldInt4:
		return m.Int4()
	case testa.FieldInt8:
		return m.Int8()
	case testa.FieldFloat4:
		return m.Float4()
	case testa.FieldFloat8:
		return m.Float8()
	case testa.FieldBool:
		return m.Bool()
	case testa.FieldText:
		return m.Text()
	case testa.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestAMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testa.FieldName:
		return m.OldName(ctx)
	case testa.FieldInt4:
		return m.OldInt4(ctx)
	case testa.FieldInt8:
		return m.OldInt8(ctx)
	case testa.FieldFloat4:
		return m.OldFloat4(ctx)
	case testa.FieldFloat8:
		return m.OldFloat8(ctx)
	case testa.FieldBool:
		return m.OldBool(ctx)
	case testa.FieldText:
		return m.OldText(ctx)
	case testa.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown TestA field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestAMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testa.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testa.FieldInt4:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInt4(v)
		return nil
	case testa.FieldInt8:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInt8(v)
		return nil
	case testa.FieldFloat4:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloat4(v)
		return nil
	case testa.FieldFloat8:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloat8(v)
		return nil
	case testa.FieldBool:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBool(v)
		return nil
	case testa.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case testa.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown TestA field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestAMutation) AddedFields() []string {
	var fields []string
	if m.addint4 != nil {
		fields = append(fields, testa.FieldInt4)
	}
	if m.addint8 != nil {
		fields = append(fields, testa.FieldInt8)
	}
	if m.addfloat4 != nil {
		fields = append(fields, testa.FieldFloat4)
	}
	if m.addfloat8 != nil {
		fields = append(fields, testa.FieldFloat8)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestAMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testa.FieldInt4:
		return m.AddedInt4()
	case testa.FieldInt8:
		return m.AddedInt8()
	case testa.FieldFloat4:
		return m.AddedFloat4()
	case testa.FieldFloat8:
		return m.AddedFloat8()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestAMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testa.FieldInt4:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInt4(v)
		return nil
	case testa.FieldInt8:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInt8(v)
		return nil
	case testa.FieldFloat4:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloat4(v)
		return nil
	case testa.FieldFloat8:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloat8(v)
		return nil
	}
	return fmt.Errorf("unknown TestA numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestAMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestAMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestAMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TestA nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestAMutation) ResetField(name string) error {
	switch name {
	case testa.FieldName:
		m.ResetName()
		return nil
	case testa.FieldInt4:
		m.ResetInt4()
		return nil
	case testa.FieldInt8:
		m.ResetInt8()
		return nil
	case testa.FieldFloat4:
		m.ResetFloat4()
		return nil
	case testa.FieldFloat8:
		m.ResetFloat8()
		return nil
	case testa.FieldBool:
		m.ResetBool()
		return nil
	case testa.FieldText:
		m.ResetText()
		return nil
	case testa.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown TestA field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestAMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.test_bs != nil {
		edges = append(edges, testa.EdgeTestBs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestAMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testa.EdgeTestBs:
		ids := make([]ent.Value, 0, len(m.test_bs))
		for id := range m.test_bs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestAMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtest_bs != nil {
		edges = append(edges, testa.EdgeTestBs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestAMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case testa.EdgeTestBs:
		ids := make([]ent.Value, 0, len(m.removedtest_bs))
		for id := range m.removedtest_bs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestAMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtest_bs {
		edges = append(edges, testa.EdgeTestBs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestAMutation) EdgeCleared(name string) bool {
	switch name {
	case testa.EdgeTestBs:
		return m.clearedtest_bs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestAMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TestA unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestAMutation) ResetEdge(name string) error {
	switch name {
	case testa.EdgeTestBs:
		m.ResetTestBs()
		return nil
	}
	return fmt.Errorf("unknown TestA edge %s", name)
}

// TestBMutation represents an operation that mutates the TestB nodes in the graph.
type TestBMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	int4           *int32
	addint4        *int32
	int8           *int
	addint8        *int
	float4         *float32
	addfloat4      *float32
	float8         *float64
	addfloat8      *float64
	bool           *bool
	text           *string
	time           *time.Time
	clearedFields  map[string]struct{}
	test_a         *int
	clearedtest_a  bool
	test_cs        map[int]struct{}
	removedtest_cs map[int]struct{}
	clearedtest_cs bool
	done           bool
	oldValue       func(context.Context) (*TestB, error)
	predicates     []predicate.TestB
}

var _ ent.Mutation = (*TestBMutation)(nil)

// testbOption allows management of the mutation configuration using functional options.
type testbOption func(*TestBMutation)

// newTestBMutation creates new mutation for the TestB entity.
func newTestBMutation(c config, op Op, opts ...testbOption) *TestBMutation {
	m := &TestBMutation{
		config:        c,
		op:            op,
		typ:           TypeTestB,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestBID sets the ID field of the mutation.
func withTestBID(id int) testbOption {
	return func(m *TestBMutation) {
		var (
			err   error
			once  sync.Once
			value *TestB
		)
		m.oldValue = func(ctx context.Context) (*TestB, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestB.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestB sets the old TestB of the mutation.
func withTestB(node *TestB) testbOption {
	return func(m *TestBMutation) {
		m.oldValue = func(context.Context) (*TestB, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestBMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestBMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestB entities.
func (m *TestBMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestBMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestBMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestB.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAID sets the "a_id" field.
func (m *TestBMutation) SetAID(i int) {
	m.test_a = &i
}

// AID returns the value of the "a_id" field in the mutation.
func (m *TestBMutation) AID() (r int, exists bool) {
	v := m.test_a
	if v == nil {
		return
	}
	return *v, true
}

// OldAID returns the old "a_id" field's value of the TestB entity.
// If the TestB object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestBMutation) OldAID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAID: %w", err)
	}
	return oldValue.AID, nil
}

// ClearAID clears the value of the "a_id" field.
func (m *TestBMutation) ClearAID() {
	m.test_a = nil
	m.clearedFields[testb.FieldAID] = struct{}{}
}

// AIDCleared returns if the "a_id" field was cleared in this mutation.
func (m *TestBMutation) AIDCleared() bool {
	_, ok := m.clearedFields[testb.FieldAID]
	return ok
}

// ResetAID resets all changes to the "a_id" field.
func (m *TestBMutation) ResetAID() {
	m.test_a = nil
	delete(m.clearedFields, testb.FieldAID)
}

// SetName sets the "name" field.
func (m *TestBMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestBMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestB entity.
// If the TestB object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestBMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestBMutation) ResetName() {
	m.name = nil
}

// SetInt4 sets the "int4" field.
func (m *TestBMutation) SetInt4(i int32) {
	m.int4 = &i
	m.addint4 = nil
}

// Int4 returns the value of the "int4" field in the mutation.
func (m *TestBMutation) Int4() (r int32, exists bool) {
	v := m.int4
	if v == nil {
		return
	}
	return *v, true
}

// OldInt4 returns the old "int4" field's value of the TestB entity.
// If the TestB object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestBMutation) OldInt4(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInt4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInt4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInt4: %w", err)
	}
	return oldValue.Int4, nil
}

// AddInt4 adds i to the "int4" field.
func (m *TestBMutation) AddInt4(i int32) {
	if m.addint4 != nil {
		*m.addint4 += i
	} else {
		m.addint4 = &i
	}
}

// AddedInt4 returns the value that was added to the "int4" field in this mutation.
func (m *TestBMutation) AddedInt4() (r int32, exists bool) {
	v := m.addint4
	if v == nil {
		return
	}
	return *v, true
}

// ResetInt4 resets all changes to the "int4" field.
func (m *TestBMutation) ResetInt4() {
	m.int4 = nil
	m.addint4 = nil
}

// SetInt8 sets the "int8" field.
func (m *TestBMutation) SetInt8(i int) {
	m.int8 = &i
	m.addint8 = nil
}

// Int8 returns the value of the "int8" field in the mutation.
func (m *TestBMutation) Int8() (r int, exists bool) {
	v := m.int8
	if v == nil {
		return
	}
	return *v, true
}

// OldInt8 returns the old "int8" field's value of the TestB entity.
// If the TestB object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestBMutation) OldInt8(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInt8 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInt8 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInt8: %w", err)
	}
	return oldValue.Int8, nil
}

// AddInt8 adds i to the "int8" field.
func (m *TestBMutation) AddInt8(i int) {
	if m.addint8 != nil {
		*m.addint8 += i
	} else {
		m.addint8 = &i
	}
}

// AddedInt8 returns the value that was added to the "int8" field in this mutation.
func (m *TestBMutation) AddedInt8() (r int, exists bool) {
	v := m.addint8
	if v == nil {
		return
	}
	return *v, true
}

// ResetInt8 resets all changes to the "int8" field.
func (m *TestBMutation) ResetInt8() {
	m.int8 = nil
	m.addint8 = nil
}

// SetFloat4 sets the "float4" field.
func (m *TestBMutation) SetFloat4(f float32) {
	m.float4 = &f
	m.addfloat4 = nil
}

// Float4 returns the value of the "float4" field in the mutation.
func (m *TestBMutation) Float4() (r float32, exists bool) {
	v := m.float4
	if v == nil {
		return
	}
	return *v, true
}

// OldFloat4 returns the old "float4" field's value of the TestB entity.
// If the TestB object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestBMutation) OldFloat4(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloat4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloat4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloat4: %w", err)
	}
	return oldValue.Float4, nil
}

// AddFloat4 adds f to the "float4" field.
func (m *TestBMutation) AddFloat4(f float32) {
	if m.addfloat4 != nil {
		*m.addfloat4 += f
	} else {
		m.addfloat4 = &f
	}
}

// AddedFloat4 returns the value that was added to the "float4" field in this mutation.
func (m *TestBMutation) AddedFloat4() (r float32, exists bool) {
	v := m.addfloat4
	if v == nil {
		return
	}
	return *v, true
}

// ResetFloat4 resets all changes to the "float4" field.
func (m *TestBMutation) ResetFloat4() {
	m.float4 = nil
	m.addfloat4 = nil
}

// SetFloat8 sets the "float8" field.
func (m *TestBMutation) SetFloat8(f float64) {
	m.float8 = &f
	m.addfloat8 = nil
}

// Float8 returns the value of the "float8" field in the mutation.
func (m *TestBMutation) Float8() (r float64, exists bool) {
	v := m.float8
	if v == nil {
		return
	}
	return *v, true
}

// OldFloat8 returns the old "float8" field's value of the TestB entity.
// If the TestB object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestBMutation) OldFloat8(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloat8 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloat8 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloat8: %w", err)
	}
	return oldValue.Float8, nil
}

// AddFloat8 adds f to the "float8" field.
func (m *TestBMutation) AddFloat8(f float64) {
	if m.addfloat8 != nil {
		*m.addfloat8 += f
	} else {
		m.addfloat8 = &f
	}
}

// AddedFloat8 returns the value that was added to the "float8" field in this mutation.
func (m *TestBMutation) AddedFloat8() (r float64, exists bool) {
	v := m.addfloat8
	if v == nil {
		return
	}
	return *v, true
}

// ResetFloat8 resets all changes to the "float8" field.
func (m *TestBMutation) ResetFloat8() {
	m.float8 = nil
	m.addfloat8 = nil
}

// SetBool sets the "bool" field.
func (m *TestBMutation) SetBool(b bool) {
	m.bool = &b
}

// Bool returns the value of the "bool" field in the mutation.
func (m *TestBMutation) Bool() (r bool, exists bool) {
	v := m.bool
	if v == nil {
		return
	}
	return *v, true
}

// OldBool returns the old "bool" field's value of the TestB entity.
// If the TestB object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestBMutation) OldBool(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBool: %w", err)
	}
	return oldValue.Bool, nil
}

// ResetBool resets all changes to the "bool" field.
func (m *TestBMutation) ResetBool() {
	m.bool = nil
}

// SetText sets the "text" field.
func (m *TestBMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *TestBMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the TestB entity.
// If the TestB object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestBMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *TestBMutation) ResetText() {
	m.text = nil
}

// SetTime sets the "time" field.
func (m *TestBMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *TestBMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the TestB entity.
// If the TestB object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestBMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *TestBMutation) ResetTime() {
	m.time = nil
}

// SetTestAID sets the "test_a" edge to the TestA entity by id.
func (m *TestBMutation) SetTestAID(id int) {
	m.test_a = &id
}

// ClearTestA clears the "test_a" edge to the TestA entity.
func (m *TestBMutation) ClearTestA() {
	m.clearedtest_a = true
	m.clearedFields[testb.FieldAID] = struct{}{}
}

// TestACleared reports if the "test_a" edge to the TestA entity was cleared.
func (m *TestBMutation) TestACleared() bool {
	return m.AIDCleared() || m.clearedtest_a
}

// TestAID returns the "test_a" edge ID in the mutation.
func (m *TestBMutation) TestAID() (id int, exists bool) {
	if m.test_a != nil {
		return *m.test_a, true
	}
	return
}

// TestAIDs returns the "test_a" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestAID instead. It exists only for internal usage by the builders.
func (m *TestBMutation) TestAIDs() (ids []int) {
	if id := m.test_a; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTestA resets all changes to the "test_a" edge.
func (m *TestBMutation) ResetTestA() {
	m.test_a = nil
	m.clearedtest_a = false
}

// AddTestCIDs adds the "test_cs" edge to the TestC entity by ids.
func (m *TestBMutation) AddTestCIDs(ids ...int) {
	if m.test_cs == nil {
		m.test_cs = make(map[int]struct{})
	}
	for i := range ids {
		m.test_cs[ids[i]] = struct{}{}
	}
}

// ClearTestCs clears the "test_cs" edge to the TestC entity.
func (m *TestBMutation) ClearTestCs() {
	m.clearedtest_cs = true
}

// TestCsCleared reports if the "test_cs" edge to the TestC entity was cleared.
func (m *TestBMutation) TestCsCleared() bool {
	return m.clearedtest_cs
}

// RemoveTestCIDs removes the "test_cs" edge to the TestC entity by IDs.
func (m *TestBMutation) RemoveTestCIDs(ids ...int) {
	if m.removedtest_cs == nil {
		m.removedtest_cs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.test_cs, ids[i])
		m.removedtest_cs[ids[i]] = struct{}{}
	}
}

// RemovedTestCs returns the removed IDs of the "test_cs" edge to the TestC entity.
func (m *TestBMutation) RemovedTestCsIDs() (ids []int) {
	for id := range m.removedtest_cs {
		ids = append(ids, id)
	}
	return
}

// TestCsIDs returns the "test_cs" edge IDs in the mutation.
func (m *TestBMutation) TestCsIDs() (ids []int) {
	for id := range m.test_cs {
		ids = append(ids, id)
	}
	return
}

// ResetTestCs resets all changes to the "test_cs" edge.
func (m *TestBMutation) ResetTestCs() {
	m.test_cs = nil
	m.clearedtest_cs = false
	m.removedtest_cs = nil
}

// Where appends a list predicates to the TestBMutation builder.
func (m *TestBMutation) Where(ps ...predicate.TestB) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestBMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestBMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestB, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestBMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestBMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestB).
func (m *TestBMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestBMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.test_a != nil {
		fields = append(fields, testb.FieldAID)
	}
	if m.name != nil {
		fields = append(fields, testb.FieldName)
	}
	if m.int4 != nil {
		fields = append(fields, testb.FieldInt4)
	}
	if m.int8 != nil {
		fields = append(fields, testb.FieldInt8)
	}
	if m.float4 != nil {
		fields = append(fields, testb.FieldFloat4)
	}
	if m.float8 != nil {
		fields = append(fields, testb.FieldFloat8)
	}
	if m.bool != nil {
		fields = append(fields, testb.FieldBool)
	}
	if m.text != nil {
		fields = append(fields, testb.FieldText)
	}
	if m.time != nil {
		fields = append(fields, testb.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestBMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testb.FieldAID:
		return m.AID()
	case testb.FieldName:
		return m.Name()
	case testb.FieldInt4:
		return m.Int4()
	case testb.FieldInt8:
		return m.Int8()
	case testb.FieldFloat4:
		return m.Float4()
	case testb.FieldFloat8:
		return m.Float8()
	case testb.FieldBool:
		return m.Bool()
	case testb.FieldText:
		return m.Text()
	case testb.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestBMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testb.FieldAID:
		return m.OldAID(ctx)
	case testb.FieldName:
		return m.OldName(ctx)
	case testb.FieldInt4:
		return m.OldInt4(ctx)
	case testb.FieldInt8:
		return m.OldInt8(ctx)
	case testb.FieldFloat4:
		return m.OldFloat4(ctx)
	case testb.FieldFloat8:
		return m.OldFloat8(ctx)
	case testb.FieldBool:
		return m.OldBool(ctx)
	case testb.FieldText:
		return m.OldText(ctx)
	case testb.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown TestB field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestBMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testb.FieldAID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAID(v)
		return nil
	case testb.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testb.FieldInt4:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInt4(v)
		return nil
	case testb.FieldInt8:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInt8(v)
		return nil
	case testb.FieldFloat4:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloat4(v)
		return nil
	case testb.FieldFloat8:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloat8(v)
		return nil
	case testb.FieldBool:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBool(v)
		return nil
	case testb.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case testb.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown TestB field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestBMutation) AddedFields() []string {
	var fields []string
	if m.addint4 != nil {
		fields = append(fields, testb.FieldInt4)
	}
	if m.addint8 != nil {
		fields = append(fields, testb.FieldInt8)
	}
	if m.addfloat4 != nil {
		fields = append(fields, testb.FieldFloat4)
	}
	if m.addfloat8 != nil {
		fields = append(fields, testb.FieldFloat8)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestBMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testb.FieldInt4:
		return m.AddedInt4()
	case testb.FieldInt8:
		return m.AddedInt8()
	case testb.FieldFloat4:
		return m.AddedFloat4()
	case testb.FieldFloat8:
		return m.AddedFloat8()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestBMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testb.FieldInt4:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInt4(v)
		return nil
	case testb.FieldInt8:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInt8(v)
		return nil
	case testb.FieldFloat4:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloat4(v)
		return nil
	case testb.FieldFloat8:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloat8(v)
		return nil
	}
	return fmt.Errorf("unknown TestB numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestBMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testb.FieldAID) {
		fields = append(fields, testb.FieldAID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestBMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestBMutation) ClearField(name string) error {
	switch name {
	case testb.FieldAID:
		m.ClearAID()
		return nil
	}
	return fmt.Errorf("unknown TestB nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestBMutation) ResetField(name string) error {
	switch name {
	case testb.FieldAID:
		m.ResetAID()
		return nil
	case testb.FieldName:
		m.ResetName()
		return nil
	case testb.FieldInt4:
		m.ResetInt4()
		return nil
	case testb.FieldInt8:
		m.ResetInt8()
		return nil
	case testb.FieldFloat4:
		m.ResetFloat4()
		return nil
	case testb.FieldFloat8:
		m.ResetFloat8()
		return nil
	case testb.FieldBool:
		m.ResetBool()
		return nil
	case testb.FieldText:
		m.ResetText()
		return nil
	case testb.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown TestB field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestBMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.test_a != nil {
		edges = append(edges, testb.EdgeTestA)
	}
	if m.test_cs != nil {
		edges = append(edges, testb.EdgeTestCs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestBMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testb.EdgeTestA:
		if id := m.test_a; id != nil {
			return []ent.Value{*id}
		}
	case testb.EdgeTestCs:
		ids := make([]ent.Value, 0, len(m.test_cs))
		for id := range m.test_cs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestBMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtest_cs != nil {
		edges = append(edges, testb.EdgeTestCs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestBMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case testb.EdgeTestCs:
		ids := make([]ent.Value, 0, len(m.removedtest_cs))
		for id := range m.removedtest_cs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestBMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtest_a {
		edges = append(edges, testb.EdgeTestA)
	}
	if m.clearedtest_cs {
		edges = append(edges, testb.EdgeTestCs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestBMutation) EdgeCleared(name string) bool {
	switch name {
	case testb.EdgeTestA:
		return m.clearedtest_a
	case testb.EdgeTestCs:
		return m.clearedtest_cs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestBMutation) ClearEdge(name string) error {
	switch name {
	case testb.EdgeTestA:
		m.ClearTestA()
		return nil
	}
	return fmt.Errorf("unknown TestB unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestBMutation) ResetEdge(name string) error {
	switch name {
	case testb.EdgeTestA:
		m.ResetTestA()
		return nil
	case testb.EdgeTestCs:
		m.ResetTestCs()
		return nil
	}
	return fmt.Errorf("unknown TestB edge %s", name)
}

// TestCMutation represents an operation that mutates the TestC nodes in the graph.
type TestCMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	int4          *int32
	addint4       *int32
	int8          *int
	addint8       *int
	float4        *float32
	addfloat4     *float32
	float8        *float64
	addfloat8     *float64
	bool          *bool
	text          *string
	time          *time.Time
	clearedFields map[string]struct{}
	test_b        *int
	clearedtest_b bool
	done          bool
	oldValue      func(context.Context) (*TestC, error)
	predicates    []predicate.TestC
}

var _ ent.Mutation = (*TestCMutation)(nil)

// testcOption allows management of the mutation configuration using functional options.
type testcOption func(*TestCMutation)

// newTestCMutation creates new mutation for the TestC entity.
func newTestCMutation(c config, op Op, opts ...testcOption) *TestCMutation {
	m := &TestCMutation{
		config:        c,
		op:            op,
		typ:           TypeTestC,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestCID sets the ID field of the mutation.
func withTestCID(id int) testcOption {
	return func(m *TestCMutation) {
		var (
			err   error
			once  sync.Once
			value *TestC
		)
		m.oldValue = func(ctx context.Context) (*TestC, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestC.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestC sets the old TestC of the mutation.
func withTestC(node *TestC) testcOption {
	return func(m *TestCMutation) {
		m.oldValue = func(context.Context) (*TestC, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestCMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestCMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestC entities.
func (m *TestCMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestCMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestCMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestC.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBID sets the "b_id" field.
func (m *TestCMutation) SetBID(i int) {
	m.test_b = &i
}

// BID returns the value of the "b_id" field in the mutation.
func (m *TestCMutation) BID() (r int, exists bool) {
	v := m.test_b
	if v == nil {
		return
	}
	return *v, true
}

// OldBID returns the old "b_id" field's value of the TestC entity.
// If the TestC object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCMutation) OldBID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBID: %w", err)
	}
	return oldValue.BID, nil
}

// ClearBID clears the value of the "b_id" field.
func (m *TestCMutation) ClearBID() {
	m.test_b = nil
	m.clearedFields[testc.FieldBID] = struct{}{}
}

// BIDCleared returns if the "b_id" field was cleared in this mutation.
func (m *TestCMutation) BIDCleared() bool {
	_, ok := m.clearedFields[testc.FieldBID]
	return ok
}

// ResetBID resets all changes to the "b_id" field.
func (m *TestCMutation) ResetBID() {
	m.test_b = nil
	delete(m.clearedFields, testc.FieldBID)
}

// SetName sets the "name" field.
func (m *TestCMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestCMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestC entity.
// If the TestC object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestCMutation) ResetName() {
	m.name = nil
}

// SetInt4 sets the "int4" field.
func (m *TestCMutation) SetInt4(i int32) {
	m.int4 = &i
	m.addint4 = nil
}

// Int4 returns the value of the "int4" field in the mutation.
func (m *TestCMutation) Int4() (r int32, exists bool) {
	v := m.int4
	if v == nil {
		return
	}
	return *v, true
}

// OldInt4 returns the old "int4" field's value of the TestC entity.
// If the TestC object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCMutation) OldInt4(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInt4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInt4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInt4: %w", err)
	}
	return oldValue.Int4, nil
}

// AddInt4 adds i to the "int4" field.
func (m *TestCMutation) AddInt4(i int32) {
	if m.addint4 != nil {
		*m.addint4 += i
	} else {
		m.addint4 = &i
	}
}

// AddedInt4 returns the value that was added to the "int4" field in this mutation.
func (m *TestCMutation) AddedInt4() (r int32, exists bool) {
	v := m.addint4
	if v == nil {
		return
	}
	return *v, true
}

// ResetInt4 resets all changes to the "int4" field.
func (m *TestCMutation) ResetInt4() {
	m.int4 = nil
	m.addint4 = nil
}

// SetInt8 sets the "int8" field.
func (m *TestCMutation) SetInt8(i int) {
	m.int8 = &i
	m.addint8 = nil
}

// Int8 returns the value of the "int8" field in the mutation.
func (m *TestCMutation) Int8() (r int, exists bool) {
	v := m.int8
	if v == nil {
		return
	}
	return *v, true
}

// OldInt8 returns the old "int8" field's value of the TestC entity.
// If the TestC object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCMutation) OldInt8(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInt8 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInt8 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInt8: %w", err)
	}
	return oldValue.Int8, nil
}

// AddInt8 adds i to the "int8" field.
func (m *TestCMutation) AddInt8(i int) {
	if m.addint8 != nil {
		*m.addint8 += i
	} else {
		m.addint8 = &i
	}
}

// AddedInt8 returns the value that was added to the "int8" field in this mutation.
func (m *TestCMutation) AddedInt8() (r int, exists bool) {
	v := m.addint8
	if v == nil {
		return
	}
	return *v, true
}

// ResetInt8 resets all changes to the "int8" field.
func (m *TestCMutation) ResetInt8() {
	m.int8 = nil
	m.addint8 = nil
}

// SetFloat4 sets the "float4" field.
func (m *TestCMutation) SetFloat4(f float32) {
	m.float4 = &f
	m.addfloat4 = nil
}

// Float4 returns the value of the "float4" field in the mutation.
func (m *TestCMutation) Float4() (r float32, exists bool) {
	v := m.float4
	if v == nil {
		return
	}
	return *v, true
}

// OldFloat4 returns the old "float4" field's value of the TestC entity.
// If the TestC object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCMutation) OldFloat4(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloat4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloat4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloat4: %w", err)
	}
	return oldValue.Float4, nil
}

// AddFloat4 adds f to the "float4" field.
func (m *TestCMutation) AddFloat4(f float32) {
	if m.addfloat4 != nil {
		*m.addfloat4 += f
	} else {
		m.addfloat4 = &f
	}
}

// AddedFloat4 returns the value that was added to the "float4" field in this mutation.
func (m *TestCMutation) AddedFloat4() (r float32, exists bool) {
	v := m.addfloat4
	if v == nil {
		return
	}
	return *v, true
}

// ResetFloat4 resets all changes to the "float4" field.
func (m *TestCMutation) ResetFloat4() {
	m.float4 = nil
	m.addfloat4 = nil
}

// SetFloat8 sets the "float8" field.
func (m *TestCMutation) SetFloat8(f float64) {
	m.float8 = &f
	m.addfloat8 = nil
}

// Float8 returns the value of the "float8" field in the mutation.
func (m *TestCMutation) Float8() (r float64, exists bool) {
	v := m.float8
	if v == nil {
		return
	}
	return *v, true
}

// OldFloat8 returns the old "float8" field's value of the TestC entity.
// If the TestC object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCMutation) OldFloat8(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloat8 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloat8 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloat8: %w", err)
	}
	return oldValue.Float8, nil
}

// AddFloat8 adds f to the "float8" field.
func (m *TestCMutation) AddFloat8(f float64) {
	if m.addfloat8 != nil {
		*m.addfloat8 += f
	} else {
		m.addfloat8 = &f
	}
}

// AddedFloat8 returns the value that was added to the "float8" field in this mutation.
func (m *TestCMutation) AddedFloat8() (r float64, exists bool) {
	v := m.addfloat8
	if v == nil {
		return
	}
	return *v, true
}

// ResetFloat8 resets all changes to the "float8" field.
func (m *TestCMutation) ResetFloat8() {
	m.float8 = nil
	m.addfloat8 = nil
}

// SetBool sets the "bool" field.
func (m *TestCMutation) SetBool(b bool) {
	m.bool = &b
}

// Bool returns the value of the "bool" field in the mutation.
func (m *TestCMutation) Bool() (r bool, exists bool) {
	v := m.bool
	if v == nil {
		return
	}
	return *v, true
}

// OldBool returns the old "bool" field's value of the TestC entity.
// If the TestC object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCMutation) OldBool(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBool: %w", err)
	}
	return oldValue.Bool, nil
}

// ResetBool resets all changes to the "bool" field.
func (m *TestCMutation) ResetBool() {
	m.bool = nil
}

// SetText sets the "text" field.
func (m *TestCMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *TestCMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the TestC entity.
// If the TestC object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *TestCMutation) ResetText() {
	m.text = nil
}

// SetTime sets the "time" field.
func (m *TestCMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *TestCMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the TestC entity.
// If the TestC object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *TestCMutation) ResetTime() {
	m.time = nil
}

// SetTestBID sets the "test_b" edge to the TestB entity by id.
func (m *TestCMutation) SetTestBID(id int) {
	m.test_b = &id
}

// ClearTestB clears the "test_b" edge to the TestB entity.
func (m *TestCMutation) ClearTestB() {
	m.clearedtest_b = true
	m.clearedFields[testc.FieldBID] = struct{}{}
}

// TestBCleared reports if the "test_b" edge to the TestB entity was cleared.
func (m *TestCMutation) TestBCleared() bool {
	return m.BIDCleared() || m.clearedtest_b
}

// TestBID returns the "test_b" edge ID in the mutation.
func (m *TestCMutation) TestBID() (id int, exists bool) {
	if m.test_b != nil {
		return *m.test_b, true
	}
	return
}

// TestBIDs returns the "test_b" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestBID instead. It exists only for internal usage by the builders.
func (m *TestCMutation) TestBIDs() (ids []int) {
	if id := m.test_b; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTestB resets all changes to the "test_b" edge.
func (m *TestCMutation) ResetTestB() {
	m.test_b = nil
	m.clearedtest_b = false
}

// Where appends a list predicates to the TestCMutation builder.
func (m *TestCMutation) Where(ps ...predicate.TestC) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestCMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestCMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestC, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestCMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestCMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestC).
func (m *TestCMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestCMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.test_b != nil {
		fields = append(fields, testc.FieldBID)
	}
	if m.name != nil {
		fields = append(fields, testc.FieldName)
	}
	if m.int4 != nil {
		fields = append(fields, testc.FieldInt4)
	}
	if m.int8 != nil {
		fields = append(fields, testc.FieldInt8)
	}
	if m.float4 != nil {
		fields = append(fields, testc.FieldFloat4)
	}
	if m.float8 != nil {
		fields = append(fields, testc.FieldFloat8)
	}
	if m.bool != nil {
		fields = append(fields, testc.FieldBool)
	}
	if m.text != nil {
		fields = append(fields, testc.FieldText)
	}
	if m.time != nil {
		fields = append(fields, testc.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestCMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testc.FieldBID:
		return m.BID()
	case testc.FieldName:
		return m.Name()
	case testc.FieldInt4:
		return m.Int4()
	case testc.FieldInt8:
		return m.Int8()
	case testc.FieldFloat4:
		return m.Float4()
	case testc.FieldFloat8:
		return m.Float8()
	case testc.FieldBool:
		return m.Bool()
	case testc.FieldText:
		return m.Text()
	case testc.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestCMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testc.FieldBID:
		return m.OldBID(ctx)
	case testc.FieldName:
		return m.OldName(ctx)
	case testc.FieldInt4:
		return m.OldInt4(ctx)
	case testc.FieldInt8:
		return m.OldInt8(ctx)
	case testc.FieldFloat4:
		return m.OldFloat4(ctx)
	case testc.FieldFloat8:
		return m.OldFloat8(ctx)
	case testc.FieldBool:
		return m.OldBool(ctx)
	case testc.FieldText:
		return m.OldText(ctx)
	case testc.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown TestC field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testc.FieldBID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBID(v)
		return nil
	case testc.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testc.FieldInt4:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInt4(v)
		return nil
	case testc.FieldInt8:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInt8(v)
		return nil
	case testc.FieldFloat4:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloat4(v)
		return nil
	case testc.FieldFloat8:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloat8(v)
		return nil
	case testc.FieldBool:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBool(v)
		return nil
	case testc.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case testc.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown TestC field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestCMutation) AddedFields() []string {
	var fields []string
	if m.addint4 != nil {
		fields = append(fields, testc.FieldInt4)
	}
	if m.addint8 != nil {
		fields = append(fields, testc.FieldInt8)
	}
	if m.addfloat4 != nil {
		fields = append(fields, testc.FieldFloat4)
	}
	if m.addfloat8 != nil {
		fields = append(fields, testc.FieldFloat8)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestCMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testc.FieldInt4:
		return m.AddedInt4()
	case testc.FieldInt8:
		return m.AddedInt8()
	case testc.FieldFloat4:
		return m.AddedFloat4()
	case testc.FieldFloat8:
		return m.AddedFloat8()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testc.FieldInt4:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInt4(v)
		return nil
	case testc.FieldInt8:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInt8(v)
		return nil
	case testc.FieldFloat4:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloat4(v)
		return nil
	case testc.FieldFloat8:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloat8(v)
		return nil
	}
	return fmt.Errorf("unknown TestC numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestCMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testc.FieldBID) {
		fields = append(fields, testc.FieldBID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestCMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestCMutation) ClearField(name string) error {
	switch name {
	case testc.FieldBID:
		m.ClearBID()
		return nil
	}
	return fmt.Errorf("unknown TestC nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestCMutation) ResetField(name string) error {
	switch name {
	case testc.FieldBID:
		m.ResetBID()
		return nil
	case testc.FieldName:
		m.ResetName()
		return nil
	case testc.FieldInt4:
		m.ResetInt4()
		return nil
	case testc.FieldInt8:
		m.ResetInt8()
		return nil
	case testc.FieldFloat4:
		m.ResetFloat4()
		return nil
	case testc.FieldFloat8:
		m.ResetFloat8()
		return nil
	case testc.FieldBool:
		m.ResetBool()
		return nil
	case testc.FieldText:
		m.ResetText()
		return nil
	case testc.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown TestC field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestCMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.test_b != nil {
		edges = append(edges, testc.EdgeTestB)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestCMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testc.EdgeTestB:
		if id := m.test_b; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestCMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestCMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestCMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtest_b {
		edges = append(edges, testc.EdgeTestB)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestCMutation) EdgeCleared(name string) bool {
	switch name {
	case testc.EdgeTestB:
		return m.clearedtest_b
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestCMutation) ClearEdge(name string) error {
	switch name {
	case testc.EdgeTestB:
		m.ClearTestB()
		return nil
	}
	return fmt.Errorf("unknown TestC unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestCMutation) ResetEdge(name string) error {
	switch name {
	case testc.EdgeTestB:
		m.ResetTestB()
		return nil
	}
	return fmt.Errorf("unknown TestC edge %s", name)
}
